#version 450 core;
#define RAYS_PER_PIXEL 4
#define RAY_DEPTH 4
#define RAY_MAX 10000
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout (binding = 0, rgba32f) uniform image2D imgOut;

// ---------- Structs ---------- //
struct Material {
    vec3 Emission;
    vec3 Albedo;
};
struct Sphere {
    vec3 Position;
    float Radius;
    Material Material;
};
struct Cuboid {
    vec3 Min;
    vec3 Max;
};

struct Ray {
    vec3 Origin;
    vec3 Direction;
};

struct RayHit {
    vec3 Position;
    vec3 Normal;
    float Distance;
    Material Material;
};
// ---------- End structs ---------- //

// ---------- Inputs ---------- //
// Some linear algebra magic
layout(std140, binding = 0) uniform BasicDataUBO {
    mat4 InverseProjectionMatrix;
    mat4 InverseViewMatrix;
    vec3 ViewPosition;
} basicDataUBO;

// Game objects that will be rendered
layout(std140, binding = 1) uniform GameObjectsUBO {
    Sphere Spheres[256];
    Cuboid Cuboids[64];
} gameObjectsUBO;

uniform vec2 gameObjectsSize;
layout(location = 0) uniform int currentFrameIndex;
// ---------- End inputs ---------- //

uint rndSeed;

// ---------- Random number stuff idk whats going on here ---------- // 
// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/
// https://github.com/BoyBaykiller/OpenTK-PathTracer/blob/master/OpenTK-PathTracer/res/shaders/PathTracing/compute.glsl
uint GetPCGHash(inout uint seed)
{
    seed = seed * 747796405u + 2891336453u;
    uint word = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;
    return (word >> 22u) ^ word;
}
float GetRandomFloat01()
{
    return float(GetPCGHash(rndSeed)) / 4294967296.0;
}

vec3 CosineSampleHemisphere(vec3 normal)
{
    float z = GetRandomFloat01() * 2.0 - 1.0;
    float a = GetRandomFloat01() * 2.0 * PI;
    float r = sqrt(1.0 - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return normalize(normal + vec3(x, y, z));
}
// ---------- End random number stuff ---------- //
// Checks if a given ray intersects with a given sphere.
// If so, rayHit will be populated with the data of the intersection.
bool rayIntersectSphere(Ray ray, Sphere sphere, out RayHit rayHit) {
    float t = dot(sphere.Position-ray.Origin);
    vec3 closestPointOnLine = ray.Origin + ray.Direction*t;
    float distanceFromLine = length(sphere.Position-closestPointOnLine);

    // If ray hits sphere, calculate ray hit coordinates
    if (distanceFromLine < sphere.Radius) {
        float x = sqrt(sphere.Radius*sphere.Radius - distanceFromLine*distanceFromLine);
        rayHit.Position = ray.Origin + ray.Direction*(t-x);
        rayHit.Distance = t-x;
        rayHit.Normal = normalize(rayHit.Position-sphere.Position); // also try (rayHit.Position-sphere.Position)/sphere.Radius;
        rayHit.Material = sphere.Material;
        return true;
    }
    return false;
}

// Creates a ray from given normalized device coordinates into the scene in world coordinates.
Ray rayFromCamera(mat4 inverseProjectionMatrix, mat4 inverseViewMatrix,vec3 viewPos,vec2 normalizedDeviceCoords) {
    // https://antongerdelan.net/opengl/raycasting.html
    // 4d Homogeneous Clip Coordinates
    vec4 rayClip = vec4(ray_nds.xy, -1.0, 1.0);
    
    // 4d camera coordinates
    vec4 rayCamera = inverseProjectionMatrix * vec4(normalizedDeviceCoords, -1.0, 0.0);
    rayCamera.zw = vec2(-1.0, 0.0);
    
    // 3d World Coordinates
    vec3 rayWorld = normalise((inverseViewMatrix * rayCamera).xyz);
    return Ray(viewPos, rayWorld);
}

// Checks if a given ray intersects any gameobject in the scene.
// If so, rayHit will be populated with the data of the intersection closest to the camera.
bool GetRayIntersection(Ray ray, out RayHit rayHit) {
    RayHit loopRayHit;
    rayHit.Distance = RAY_MAX;
    for(int i = 0; i < gameObjectsSize.x; i++) {
        Sphere sphere = gameObjectsUBO.Spheres[i];
        
        if(rayIntersectSphere(ray, shere, loopRayHit)) {
            if(loopRayHit.Distance < rayHit.Distance) {
                rayHit = loopRayHit;
            }
        }
    }
    
    return rayHit.Distance != RAY_MAX;
}

// Gets the color of a given ray with all the bounces and stuff.
vec3 getColor(Ray ray) {
    RayHit rayHit;
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    for(int i = 0; i < RAY_DEPTH; i++) {
        if(GetRayIntersection(ray, rayHit)) {
            // Mix the colors
            color += rayHit.Material.Emission * throughput;
            throughput *= rayHit.Material.Albedo;
            
            // Update ray
            ray.Origin = rayHit.Position;
            ray.Direction = CosineSampleHemisphere(rayHit.Normal);
        } else {
            break;
        }
    }
    color /= RAY_DEPTH;
    return color;
}

void main() {
    // random number stuff
    rndSeed = gl_GlobalInvocationID.x * 1973 + gl_GlobalInvocationID.y * 9277 + currentFrameIndex * 2699 | 1;
    
    // Get pixel coordinates as well as normalized between [-1,1]
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    vec2 normalizedDeviceCoordinates = pos/imageSize(imgOut)*2-1;
    
    // Shoot out a couple rays, the average color will be the color of the pixel
    vec3 color = vec3(0.0);
    for (int i = 0; i < RAYS_PER_PIXEL; i++) {
        Ray ray = rayFromCamera(basicDataUBO.InverseProjectionMatrix, basicDataUBO.InverseViewMatrix, basicDataUBO.ViewPosition, normalizedDeviceCoordinates);
        color += getColor(ray);
    }
    color /= RAYS_PER_PIXEL;
    
    // Store it in the image and were done
    imageStore(imgOut, pos, vec4(color, 1.0));
}