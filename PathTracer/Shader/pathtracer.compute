#version 450 core
#define RAYS_PER_PIXEL 1
#define RAY_DEPTH 10
#define RAY_MAX 10000.0
#define PI 3.1415926535
layout (local_size_x=8, local_size_y=4, local_size_z=1) in;
layout (binding=0, rgba32f) uniform image2D imgOut;

// ---------- Structs ---------- //
struct Material
{
    vec3 Emission;
    float Specularity;
    vec3 Albedo;
};

struct Sphere
{
    vec3 Position;
    float Radius;
    Material Material;
};

struct Cuboid
{
// No hit support for cuboids yet so dont use them
    vec3 Min;
    vec3 Max;
    Material Material;
};

struct Ray
{
    vec3 Origin;
    vec3 Direction;
};

struct RayHit
{
    vec3 Position;
    vec3 Normal;
    float Distance;
    Material Material;
};

// ---------- End structs ---------- //

// ---------- Inputs ---------- //
// Some linear algebra magic
layout(std140, binding = 0)
uniform BasicDataUBO
{
    mat4 InverseProjectionMatrix;
    mat4 InverseViewMatrix;
    vec3 ViewPosition;
} basicDataUBO;

// Game objects that will be rendered
layout(std140, binding = 1)
uniform GameObjectsUBO {
    Sphere Spheres[256];
    Cuboid Cuboids[64];
} gameObjectsUBO;

layout (location=0) uniform uint currentFrameIndex;
layout (location=1) uniform vec2 gameObjectsSize;
// ---------- End inputs ---------- //

uint rndSeed;

// ---------- Random number stuff idk whats going on here ---------- // 
// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/
// https://github.com/BoyBaykiller/OpenTK-PathTracer/blob/master/OpenTK-PathTracer/res/shaders/PathTracing/compute.glsl
uint GetPCGHash(inout uint seed)
{
    seed = seed * 747796405u + 2891336453u;
    uint word = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;
    return (word >> 22u) ^ word;
}

float GetRandomFloat01()
{
    return float(GetPCGHash(rndSeed)) / 4294967296.0;
}

vec3 CosineSampleHemisphere(vec3 normal)
{
    float z = GetRandomFloat01() * 2.0 - 1.0;
    float a = GetRandomFloat01() * 2.0 * PI;
    float r = sqrt(1.0 - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return normalize(normal + vec3(x, y, z));
}

// ---------- End random number stuff ---------- //
// Checks if a given ray intersects with a given sphere.
// If so, rayHit will be populated with the data of the intersection.
bool rayIntersectSphere(Ray ray, Sphere sphere, out RayHit rayHit)
{
    float t = dot(sphere.Position - ray.Origin, ray.Direction);
    vec3 closestPointOnLine = ray.Origin + ray.Direction * t;
    float distanceFromLine = length(sphere.Position - closestPointOnLine);

    // If ray hits sphere, calculate ray hit coordinates
    if (distanceFromLine < sphere.Radius)
    {
        float x = sqrt(sphere.Radius * sphere.Radius - distanceFromLine * distanceFromLine);
        float t1 = t - x;
        float t2 = t + x;
        float target;
        if (t1 > 0 && t1 < t2) {
            target = t1;
        } else if (t2 > 0 && t2 < t1) {
            target = t2;
        } else {
            return false;
        }

        rayHit.Position = ray.Origin + ray.Direction * target;
        rayHit.Distance = target;

        rayHit.Normal = normalize(rayHit.Position-sphere.Position);
        rayHit.Material = sphere.Material;
        return true;
    }
    return false;
}

bool rayIntersectCuboid(Ray ray, Cuboid cuboid, out RayHit rayHit) {
    vec3 a1 = (cuboid.Min - ray.Origin) / ray.Direction;
    vec3 a2 = (cuboid.Max - ray.Origin) / ray.Direction;

    vec3 tsmall = min(a1, a2);
    vec3 tlarge = max(a1, a2);

    float t1 = max(-3.4028235e+38, max(tsmall.x, max(tsmall.y, tsmall.z)));
    float t2 = min(3.4028235e+38, min(tlarge.x, min(tlarge.y, tlarge.z)));

    float target=t1;
    if (t2< 0) {
        return false;
    }

    // if tmin > tmax, ray doesn't intersect AABB
    if (t1 > t2) {
        return false;
    }
    if (t1 < 0.0f) {
        target =t2;
    }
    vec3 position = ray.Origin + ray.Direction*target;

    vec3 halfSize = (cuboid.Max - cuboid.Min) * 0.5;
    vec3 centerSurface = position - (cuboid.Max + cuboid.Min) * 0.5;

    vec3 normal = vec3(0.0);
    normal += vec3(sign(centerSurface.x), 0.0, 0.0) * step(abs(abs(centerSurface.x) - halfSize.x), 0.001f);
    normal += vec3(0.0, sign(centerSurface.y), 0.0) * step(abs(abs(centerSurface.y) - halfSize.y), 0.001f);
    normal += vec3(0.0, 0.0, sign(centerSurface.z)) * step(abs(abs(centerSurface.z) - halfSize.z), 0.001f);

    rayHit.Distance = target;
    rayHit.Material = cuboid.Material;
    rayHit.Position = position;
    rayHit.Normal = normalize(normal);
    return true;
}

// Creates a ray from given normalized device coordinates into the scene in world coordinates.
Ray rayFromCamera(mat4 inverseProjectionMatrix, mat4 inverseViewMatrix, vec3 viewPos, vec2 normalizedDeviceCoords)
{
    // https://antongerdelan.net/opengl/raycasting.html
    // 4d Homogeneous Clip Coordinates
    vec4 rayClip = vec4(normalizedDeviceCoords.xy, -1.0, 1.0);

    // 4d camera coordinates
    vec4 rayCamera = inverseProjectionMatrix * vec4(normalizedDeviceCoords, -1.0, 0.0);
    rayCamera.zw = vec2(-1.0, 0.0);

    // 3d World Coordinates
    vec3 rayWorld = normalize((inverseViewMatrix * rayCamera).xyz);
    return Ray(viewPos, rayWorld);
}

// Checks if a given ray intersects any gameobject in the scene.
// If so, rayHit will be populated with the data of the intersection closest to the camera.
bool GetRayIntersection(Ray ray, out RayHit rayHit)
{
    RayHit loopRayHit;
    rayHit.Distance = RAY_MAX;
    for (int i = 0; i < gameObjectsSize.x; i++) {
        Sphere sphere = gameObjectsUBO.Spheres[i];

        if (rayIntersectSphere(ray, sphere, loopRayHit)) {
            if (loopRayHit.Distance < rayHit.Distance) {
                rayHit = loopRayHit;
            }
        }
    }

    for (int i = 0; i < gameObjectsSize.y; i++) {
        Cuboid cuboid = gameObjectsUBO.Cuboids[i];

        if (rayIntersectCuboid(ray, cuboid, loopRayHit)) {
            if (loopRayHit.Distance < rayHit.Distance) {
                rayHit = loopRayHit;
            }
        }
    }
    return rayHit.Distance < RAY_MAX;
}

float BRDF(Ray ray, RayHit rayHit, out Ray newRay) {
    float rayProbability;
    vec3 newRayDirection;
    
    float reflectRoll = GetRandomFloat01();
    if (rayHit.Material.Specularity > reflectRoll) {
        newRayDirection = reflect(ray.Direction, rayHit.Normal);
        rayProbability = rayHit.Material.Specularity;
    } else {
        newRayDirection = CosineSampleHemisphere(rayHit.Normal);
        rayProbability = 1.0f - rayHit.Material.Specularity;
    }
    newRay.Direction = newRayDirection;
    newRay.Origin = rayHit.Position + newRay.Direction*0.001f;
    return rayProbability;
}

// Gets the color of a given ray with all the bounces and stuff.
vec3 getColor(Ray ray)
{
    RayHit rayHit;
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    for (int i = 0; i < RAY_DEPTH; i++)
    {
        if (GetRayIntersection(ray, rayHit))
        {
            // Mix the colors
            color += rayHit.Material.Emission * throughput;
            throughput *= rayHit.Material.Albedo;
            float rayProbability = BRDF(ray, rayHit, ray);
            throughput /= rayProbability;
            // Russian roulette
            float propagationChance = max(max(throughput.x, throughput.y), throughput.z);
            if (GetRandomFloat01() > propagationChance) {
                break;
            }
            throughput /= propagationChance;

            // Update ray
        }
        else
        {
            //color += throughput * vec3(0.3f);
            break;
        }
    }
    return color;
}

void main()
{
    // random number stuff
    rndSeed = gl_GlobalInvocationID.x * 1973 + gl_GlobalInvocationID.y * 9277 + currentFrameIndex * 2699 | 1;

    // Get pixel coordinates as well as normalized between [-1,1]
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    // Shoot out a couple rays, the average color will be the color of the pixel
    vec3 color = vec3(0.0);
    for (int i = 0; i < RAYS_PER_PIXEL; i++)
    {
        vec2 offset = vec2(GetRandomFloat01(), GetRandomFloat01());
        vec2 normalizedDeviceCoordinates = vec2(pos+offset) / vec2(imageSize(imgOut)) * 2 - 1;
        Ray ray = rayFromCamera(basicDataUBO.InverseProjectionMatrix, basicDataUBO.InverseViewMatrix, basicDataUBO.ViewPosition, normalizedDeviceCoordinates);
        color += getColor(ray);
    }

    color /= RAYS_PER_PIXEL;

    // Progressive rendering
    vec3 lastColor = imageLoad(imgOut, pos).rgb;
    color = mix(lastColor, color, 1.0/(currentFrameIndex+1));

    // Store it in the image and were done
    imageStore(imgOut, pos, vec4(color, 1.0));
}
